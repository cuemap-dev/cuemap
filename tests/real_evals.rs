use cuemap_rust::evals::runner::{Eval, EvalRunner};
use cuemap_rust::evals::evals::recall_correctness::{SpecificitySensitivityEval, NegativeKnowledgeEval};
use cuemap_rust::persistence::PersistenceManager;
use cuemap_rust::engine::CueMapEngine;
use std::path::PathBuf;

struct RealEvalContext {
    runner: EvalRunner,
    engine: CueMapEngine,
}

fn setup_real_context() -> RealEvalContext {
    let snapshot_path = PathBuf::from("data/snapshots/rust_engine.bin");
    let reports_dir = PathBuf::from("data/reports");
    
    // Ensure snapshot exists (it should have been generated by create_fixture)
    if !snapshot_path.exists() {
         panic!("Real snapshot not found at {:?}. Run `cargo run --bin create_fixture src data/snapshots/rust_engine.bin` first.", snapshot_path);
    }

    let (memories, cue_index) = PersistenceManager::load_from_path(&snapshot_path).expect("Failed to load snapshot");
    let engine = CueMapEngine::from_state(memories, cue_index);

    let runner = EvalRunner::new(
        Some(snapshot_path.to_string_lossy().to_string()),
        reports_dir
    );

    RealEvalContext { runner, engine }
}

#[test]
fn test_real_specificity_engine() {
    let ctx = setup_real_context();
    
    let eval = SpecificitySensitivityEval {
        general_query: vec!["lib".to_string()], // "lib" should definitely hit lib.rs
        specific_query: vec!["runner".to_string()],
        general_target_id: "lib.rs".to_string(), 
        specific_target_id: "evals/runner.rs".to_string(),
    };
    
    let result = eval.run(&ctx.engine);
    
    ctx.runner.save_report("real_specificity_runner", result).expect("Failed to save report");
}

#[test]
fn test_real_negative_knowledge() {
    let ctx = setup_real_context();
    
    let eval = NegativeKnowledgeEval {
        query: vec!["banana_muffin_recipe".to_string()],
        match_integrity_threshold: 0.2, 
    };
    
    let result = eval.run(&ctx.engine);
    ctx.runner.save_report("real_negative_knowledge", result).expect("Failed to save report");
}
